import axios from 'axios';
import { Platform } from 'react-native';
import TavilyService from './TavilyService';
import { getBackendURL } from '../config/api';

class AIAssistantService {
  constructor() {
    // URL dynamique bas√©e sur la configuration centralis√©e
    this.apiBaseUrl = getBackendURL(Platform.OS);
    
    this.chatHistory = [];
    this.maxHistoryLength = 20;
    this.conversationContext = null;
    
    console.log('üîß AIAssistantService - URL API:', this.apiBaseUrl);
  }

  async processMessage(message, options = {}) {
    try {
      // Analyser le type de message et la meilleure strat√©gie de r√©ponse
      const messageAnalysis = this.analyzeMessage(message);
      
      // Ajouter le message utilisateur √† l'historique
      this.addToHistory(message, 'user');
      
      let response;
      
      // Pour un chat rapide et d√©taill√©, toujours traiter comme conseil g√©n√©ral avec l'IA
      response = await this.handleGeneralAdvice(message, messageAnalysis, options.image);
      
      // Ajouter la r√©ponse √† l'historique
      this.addToHistory(response.text, 'assistant');
      
      return {
        text: response.text,
        type: messageAnalysis.type,
        confidence: response.confidence || 'high',
        sources: response.sources || [],
        suggestions: response.suggestions || [],
        model_used: response.model_used || 'ai',
        timestamp: new Date().toISOString(),
        context: messageAnalysis.context,
        processing_time: response.processing_time || 0
      };
      
    } catch (error) {
      console.error('‚ùå Erreur traitement message IA:', error);
      return {
        text: "Je rencontre une difficult√© technique temporaire. Pouvez-vous r√©essayer votre demande ?",
        type: 'error',
        confidence: 'low',
        error: error.message,
        timestamp: new Date().toISOString()
      };
    }
  }

  analyzeMessage(message) {
    const lowerMessage = message.toLowerCase();
    const analysis = {
      type: 'general_advice',
      context: [],
      keywords: [],
      urgency: 'normal',
      complexity: 'medium'
    };

    // Extraire les mots-cl√©s importants
    const keywords = this.extractKeywords(lowerMessage);
    analysis.keywords = keywords;

    // D√©terminer le type de question
    if (this.isPriceInquiry(lowerMessage)) {
      analysis.type = 'price_inquiry';
      analysis.context.push('market_data', 'price_trends');
    } else if (this.isDiagnostic(lowerMessage)) {
      analysis.type = 'diagnostic';
      analysis.context.push('plant_health', 'disease_detection');
      analysis.urgency = 'high';
    } else if (this.isTechnicalSupport(lowerMessage)) {
      analysis.type = 'technical_support';
      analysis.context.push('equipment', 'machinery', 'technology');
    } else if (this.isEcommerce(lowerMessage)) {
      analysis.type = 'ecommerce';
      analysis.context.push('products', 'suppliers', 'marketplace');
    }

    // √âvaluer l'urgence
    if (lowerMessage.includes('urgent') || lowerMessage.includes('probl√®me grave') || 
        lowerMessage.includes('maladie') || lowerMessage.includes('pest')) {
      analysis.urgency = 'high';
    }

    // √âvaluer la complexit√©
    if (keywords.length > 5 || lowerMessage.length > 200) {
      analysis.complexity = 'high';
    } else if (keywords.length <= 2 || lowerMessage.length < 50) {
      analysis.complexity = 'low';
    }

    return analysis;
  }

  isPriceInquiry(message) {
    const priceKeywords = ['prix', 'co√ªt', 'tarif', 'march√©', 'cours', 'valeur', 'vendre', 'acheter', 'commerce'];
    return priceKeywords.some(keyword => message.includes(keyword));
  }

  isDiagnostic(message) {
    const diagnosticKeywords = ['maladie', 'probl√®me', 'sympt√¥me', 'diagnostic', 'traitement', 'soigner', 'gu√©rir', 'parasite', 'champignon', 'virus', 'bact√©rie'];
    return diagnosticKeywords.some(keyword => message.includes(keyword));
  }

  isTechnicalSupport(message) {
    const techKeywords = ['tracteur', 'machine', '√©quipement', 'panne', 'r√©paration', 'maintenance', 'technique', 'installation', 'configuration'];
    return techKeywords.some(keyword => message.includes(keyword));
  }

  isEcommerce(message) {
    const ecommerceKeywords = ['acheter', 'vendre', 'commande', 'fournisseur', 'produit', 'livraison', 'magasin', 'boutique', 'marketplace'];
    return ecommerceKeywords.some(keyword => message.includes(keyword));
  }

  extractKeywords(message) {
    const agriculturalTerms = [
      'bl√©', 'ma√Øs', 'orge', 'avoine', 'soja', 'tournesol', 'colza',
      'tomate', 'pomme de terre', 'carotte', 'oignon', 'salade',
      'pomme', 'poire', 'cerise', 'raisin', 'p√™che',
      'vache', 'porc', 'mouton', 'ch√®vre', 'poule', 'b≈ìuf',
      'tracteur', 'moissonneuse', 'semoir', 'charrue', 'herse',
      'irrigation', 'fertilisant', 'pesticide', 'herbicide', 'fongicide',
      'sol', 'terre', 'champ', 'culture', 'plantation', 'r√©colte',
      'maladie', 'parasite', 'champignon', 'virus', 'traitement'
    ];
    
    return agriculturalTerms.filter(term => message.includes(term));
  }

  async handlePriceInquiry(message, analysis) {
    try {
      // Rechercher les prix avec Tavily
      const priceData = await TavilyService.searchPrices(message, {
        depth: 'advanced',
        maxResults: 3
      });

      // Enrichir avec l'IA pour interpr√©ter les donn√©es
      const aiPrompt = `Question sur les prix: ${message}

Donn√©es de march√© trouv√©es:
${priceData.summary}

Prix d√©tect√©s: ${JSON.stringify(priceData.prices, null, 2)}

En tant qu'expert agricole, fournis une analyse compl√®te incluant:
1. Interpr√©tation des prix actuels
2. Comparaison avec les moyennes historiques si possible
3. Tendances et pr√©visions
4. Conseils √©conomiques pour l'agriculteur
5. Facteurs influen√ßant ces prix`;

      const aiResponse = await this.callAIAPI(aiPrompt, 'price_analysis');

      return {
        text: aiResponse.advice,
        confidence: 'high',
        sources: priceData.sources,
        market_data: priceData,
        suggestions: this.generatePriceSuggestions(analysis.keywords)
      };
      
    } catch (error) {
      console.error('‚ùå Erreur requ√™te prix:', error);
      // Fallback sur l'IA seule
      return await this.handleGeneralAdvice(message, analysis);
    }
  }

  async handleDiagnostic(message, analysis, image = null) {
    try {
      let prompt = `Diagnostic agricole urgent: ${message}

En tant qu'expert phytosanitaire, fournis:
1. Analyse des sympt√¥mes d√©crits
2. Causes possibles (maladie, parasite, carence, stress)
3. Diagnostic le plus probable
4. Traitement recommand√© √©tape par √©tape
5. Mesures pr√©ventives
6. Urgence d'intervention (1-10)
7. Co√ªt estim√© du traitement`;

      if (image) {
        prompt += `\n\nImage fournie: Analyse √©galement l'image pour confirmer le diagnostic.`;
      }

      const response = await this.callAIAPI(prompt, 'diagnostic', image);

      return {
        text: response.advice,
        confidence: 'high',
        model_used: response.model_used,
        suggestions: this.generateDiagnosticSuggestions(analysis.keywords),
        urgency: analysis.urgency
      };
      
    } catch (error) {
      console.error('‚ùå Erreur diagnostic:', error);
      return await this.handleGeneralAdvice(message, analysis);
    }
  }

  async handleTechnicalSupport(message, analysis) {
    const prompt = `Support technique agricole: ${message}

En tant qu'expert en machinisme agricole, fournis:
1. Analyse du probl√®me technique
2. Solutions √©tape par √©tape
3. Outils/pi√®ces n√©cessaires
4. Niveau de difficult√© (d√©butant/expert)
5. Co√ªt estim√© de la r√©paration
6. Conseils de s√©curit√©
7. Maintenance pr√©ventive`;

    const response = await this.callAIAPI(prompt, 'technical_support');

    return {
      text: response.advice,
      confidence: 'medium',
      model_used: response.model_used,
      suggestions: this.generateTechnicalSuggestions(analysis.keywords)
    };
  }

  async handleEcommerce(message, analysis) {
    try {
      // Rechercher des produits/fournisseurs avec Tavily
      const searchResults = await TavilyService.searchMarketTrends(message, {
        period: '2024'
      });

      const prompt = `Question e-commerce agricole: ${message}

Informations march√©:
${searchResults.trend}

En tant qu'expert en commerce agricole, fournis:
1. Recommandations d'achat/vente
2. Meilleurs fournisseurs/plateformes
3. N√©gociation et prix
4. Logistique et livraison
5. Aspects r√©glementaires
6. Opportunit√©s de march√©`;

      const response = await this.callAIAPI(prompt, 'ecommerce');

      return {
        text: response.advice,
        confidence: 'medium',
        model_used: response.model_used,
        sources: searchResults.sources,
        suggestions: this.generateEcommerceSuggestions(analysis.keywords)
      };
      
    } catch (error) {
      return await this.handleGeneralAdvice(message, analysis);
    }
  }

  async handleGeneralAdvice(message, analysis, image = null) {
    const context = this.buildConversationContext();
    const startTime = Date.now();
    
    // Prompt optimis√© pour chat agricole
    const prompt = `${context}

Demande agricole: ${message}

Vous √™tes un assistant agricole expert sp√©cialis√© dans les conseils pratiques et d√©taill√©s.
R√©pondez de mani√®re conversationnelle, claire et directe comme dans un chat.
Donnez des conseils pr√©cis, pratiques et adapt√©s au contexte agricole africain/s√©n√©galais.

Votre r√©ponse doit √™tre:
- Directe et conversationnelle (comme un chat)
- D√©taill√©e mais structur√©e avec des √©mojis
- Pratique avec des actions concr√®tes
- Adapt√©e au climat tropical/sah√©lien

Ne mentionnez jamais le mot "question" dans votre r√©ponse.`;

    const response = await this.callAIAPI(prompt, 'general_advice', image);
    const processingTime = Date.now() - startTime;

    return {
      text: response.advice,
      confidence: 'high',
      model_used: response.model_used,
      processing_time: processingTime,
      suggestions: this.generateGeneralSuggestions(analysis.keywords)
    };
  }

  async callAIAPI(prompt, type, image = null) {
    // URLs √† tester dans l'ordre de priorit√© selon la plateforme
    let urlsToTry;
    
    if (Platform.OS === 'android') {
      // Pour Android (√©mulateur d'abord, puis physique)
      urlsToTry = [
        'http://10.0.2.2:8000',       // √âmulateur Android
        'http://192.168.1.100:8000',  // Appareil physique Android
        this.apiBaseUrl,
        'http://localhost:8000'
      ];
    } else if (Platform.OS === 'ios') {
      // Pour iOS (simulateur d'abord, puis physique)
      urlsToTry = [
        'http://localhost:8000',      // Simulateur iOS
        'http://192.168.1.100:8000',  // Appareil physique iOS
        this.apiBaseUrl,
        'http://10.0.2.2:8000'
      ];
    } else {
      // Pour autres plateformes
      urlsToTry = [
        this.apiBaseUrl,
        'http://192.168.1.100:8000',
        'http://localhost:8000',
        'http://10.0.2.2:8000'
      ];
    }

    let lastError = null;

    for (const url of urlsToTry) {
      try {
        console.log(`üîÑ Test connexion API: ${url}`);
        
        const formData = new FormData();
        formData.append('prompt', prompt);
        formData.append('advice_type', type);
        formData.append('conversation_history', JSON.stringify(this.getRecentHistory()));

        if (image) {
          formData.append('file', {
            uri: image.uri,
            type: image.type || 'image/jpeg',
            name: image.name || 'diagnostic.jpg'
          });
        }

        const response = await axios.post(`${url}/api/assistant/chat`, formData, {
          headers: {
            'Content-Type': 'multipart/form-data',
            'Accept': 'application/json',
          },
          timeout: 30000, // 30 secondes par tentative
        });

        console.log(`‚úÖ Connexion r√©ussie avec: ${url}`);
        
        // Mettre √† jour l'URL qui fonctionne pour les prochaines requ√™tes
        this.apiBaseUrl = url;
        
        // La nouvelle API retourne un format diff√©rent
        return {
          advice: response.data.response,
          model_used: response.data.model_used,
          timestamp: response.data.timestamp,
          has_image: response.data.has_image,
          conversation_id: response.data.conversation_id
        };
        
      } catch (error) {
        console.log(`‚ùå √âchec connexion ${url}:`, error.message);
        lastError = error;
        continue;
      }
    }

    console.error('‚ùå Toutes les tentatives de connexion ont √©chou√©');
    throw lastError || new Error('Impossible de se connecter √† l\'API backend');
  }

  buildConversationContext() {
    const recentMessages = this.getRecentHistory(5);
    if (recentMessages.length === 0) return "";
    
    return `Contexte de conversation:
${recentMessages.map(msg => `${msg.role}: ${msg.content}`).join('\n')}
`;
  }

  addToHistory(message, role) {
    this.chatHistory.push({
      content: message,
      role: role,
      timestamp: new Date().toISOString()
    });
    
    // Limiter la taille de l'historique
    if (this.chatHistory.length > this.maxHistoryLength) {
      this.chatHistory = this.chatHistory.slice(-this.maxHistoryLength);
    }
  }

  getRecentHistory(count = 10) {
    return this.chatHistory.slice(-count);
  }

  generatePriceSuggestions(keywords) {
    return [
      "üìà Voir l'√©volution des prix sur 6 mois",
      "üí∞ Comparer avec d'autres produits",
      "üéØ Optimiser le moment de vente",
      "üìä Analyser les tendances du march√©"
    ];
  }

  generateDiagnosticSuggestions(keywords) {
    return [
      "üì∏ Prendre plus de photos des sympt√¥mes",
      "üî¨ Tests de sol recommand√©s",
      "‚ö° Actions d'urgence √† prendre",
      "üõ°Ô∏è Plan de pr√©vention"
    ];
  }

  generateTechnicalSuggestions(keywords) {
    return [
      "üîß Guide de maintenance",
      "üìû Contacter un technicien",
      "üí° Alternatives temporaires",
      "üìã Check-list de v√©rification"
    ];
  }

  generateEcommerceSuggestions(keywords) {
    return [
      "üè™ Trouver des fournisseurs locaux",
      "üí≥ Comparer les prix",
      "üöö Options de livraison",
      "üìÑ V√©rifier les certifications"
    ];
  }

  generateGeneralSuggestions(keywords) {
    return [
      "‚ùì Poser une question plus sp√©cifique",
      "üìñ Consulter nos guides",
      "ü§ù Partager avec la communaut√©",
      "üìû Contacter un expert"
    ];
  }

  clearHistory() {
    this.chatHistory = [];
    this.conversationContext = null;
  }

  async testConnection() {
    try {
      console.log('üîç Test de connexion √† l\'API backend...');
      
      // Essayer d'abord l'endpoint de test de l'assistant
      const response = await axios.post(`${this.apiBaseUrl}/api/assistant/test-connection`, {}, {
        headers: {
          'Accept': 'application/json',
        },
        timeout: 10000, // 10 secondes pour le test
      });

      console.log('‚úÖ Test de connexion r√©ussi');
      return {
        success: true,
        url: this.apiBaseUrl,
        response: response.data
      };
      
    } catch (error) {
      console.log('‚ùå Test de connexion √©chou√©:', error.message);
      return {
        success: false,
        error: error.message,
        url: this.apiBaseUrl
      };
    }
  }

  getStats() {
    return {
      totalMessages: this.chatHistory.length,
      conversationStarted: this.chatHistory.length > 0 ? this.chatHistory[0].timestamp : null,
      lastActivity: this.chatHistory.length > 0 ? this.chatHistory[this.chatHistory.length - 1].timestamp : null,
      currentApiUrl: this.apiBaseUrl
    };
  }
}

export default new AIAssistantService();